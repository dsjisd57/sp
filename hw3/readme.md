參考gemini
no race
銀行帳戶類別：

__init__：使用初始餘額初始化帳戶。
提款：嘗試提取指定金額。如果成功，則更新餘額並返回新餘額。否則，引發 ValueError。
存款：存入指定金額，更新餘額，並返回新餘額。
執行交易函數：

使用 for 迴圈模擬多個並發提款和存款。
隨機選擇交易類型（「提款」或「存款」）和金額。
在帳戶物件上呼叫對應的提款或存款方法。
列印交易詳細資料和餘額。
每筆交易後，透過將預期餘額（初始餘額+交易總和）與帳戶物件的實際餘額進行比較來驗證餘額一致性。如果它們不匹配，則會列印錯誤訊息。
主要程序：

建立初始餘額為 1000 美元的 BankAccount 物件。
初始化一個空的交易列表來追蹤交易。
使用 time.time() 記錄開始時間。
使用 for 迴圈建立 10 個線程，每個線程都呼叫 Perform_transactions 函數。
使用 thread.start() 啟動所有執行緒。
使用 thread.join() 等待所有執行緒完成。
使用 time.time() 記錄結束時間。
計算並列印總執行時間。
競爭條件問題：
在此版本中，如果不使用互斥鎖來同步對共享餘額變數的訪問，多個執行緒可以嘗試同時修改餘額，從而導致競爭條件。這可能會導致餘額變得不準確和不一致，因為由於並發更新，perform_transactions 中的預期餘額計算可能無法反映實際餘額。
競爭條件問題

race
版本 2 的變化：

互斥量的用法：
名為 mutex 的 threading.Lock 物件被加入到 BankAccount 類別中。
提款和存款方法現在使用 with 語句在修改餘額變數之前取得鎖，並在操作完成後釋放它。這確保一次只有一個執行緒可以存取和修改餘額，從而防止競爭情況。
互斥鎖的好處：

透過使用互斥體，我們確保一次只有一個執行緒可以修改餘額變數。這避免了先前版本中由於競爭條件而可能出現的不一致。
現在，perform_transactions 函數中的預期餘額計算將始終反映帳戶物件中的實際餘額，因為互斥體保證對關鍵部分的獨佔存取（修改餘額）。
