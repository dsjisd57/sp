參考gemini

fork() 函數：

fork()函數用來建立一個新行程。
它向子進程返回0，並且向父進程返回子進程的進程ID。
如果 fork() 失敗，則傳回 -1。
印刷“喬治”和“瑪麗”：

在子進程中，使用無限迴圈分別以一秒或兩秒的延遲重複列印「George」或「Mary」。
列印分隔符號：

在父進程中，使用無限循環，延遲一秒重複列印分隔線「----------------」。
與 pthreads 版本的差異：

流程創建：
fork() 用於建立子進程，而不是使用 pthread_create() 建立執行緒。
同步：
由於進程在自己獨立的記憶體空間中運行，並且預設不共享變量，因此不需要互斥體或信號量等同步原語。
溝通：
進程可以使用進程間通訊 (IPC) 機制（例如管道、訊息佇列或共享記憶體）進行通訊。在本例中這不是必需的，因為每個進程只是獨立地列印自己的訊息。
fork() 的優點：

輕量級：使用 fork() 建立新進程通常比使用 pthread_create() 建立新執行緒更快、更輕。
資源共享：進程有自己獨立的記憶體空間，有利於資源隔離和安全。
fork() 的缺點：

通訊：進程需要使用IPC機制來相互通信，這會增加複雜性。
同步：如果進程需要共享資料或同步對資源的訪問，則可能需要額外的同步機制。
結論：

pthreads 和 fork() 都可以用來建立並發任務。它們之間的選擇取決於應用程式的特定要求，例如共享資料的需要、執行緒/進程之間的通訊以及效能考量。
